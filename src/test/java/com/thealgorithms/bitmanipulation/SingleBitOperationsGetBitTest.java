
// ********RoostGPT********
/*
Test generated by RoostGPT for test Java-test-1 using AI Type  and AI Model

ROOST_METHOD_HASH=getBit_487c75a4b3
ROOST_METHOD_SIG_HASH=getBit_2ea30e777d

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/Java-test-1/4fe02726-06d9-4581-a823-6990ffcbda14/source/Algorithms_Java/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void getBitTest() {
    assertEquals(0, SingleBitOperations.getBit(6, 0));
    assertEquals(1, SingleBitOperations.getBit(7, 1));
}
""""
Scenario 1: Get Bit at position 0 of a positive number
Details:
  TestName: getBitAtPosition0FromPositiveNumber
  Description: This test checks the getBit method to retrieve the bit value from position 0 of a positive number.
Execution:
  Arrange: No arrangement needed as we are directly dealing with a method that does not use other initialization or state mechanisms.
  Act: Invoke the getBit method from SingleBitOperations with a positive number and bit position 0.
  Assert: Using JUnit assertion equalTo, check if the return value is 1 or 0 depending on the input value.
Validation:
  Aim of this assertion is to verify if the method correctly returns the bit at the specified position. Significance of the test is to ensure correctness of bit operations which is crucial to the system if it is used for encryption or other bit level operations.


Scenario 2: Get Bit from a negative number
Details:
  TestName: getBitFromNegativeNumber
  Description: This test checks the getBit method to retrieve the bit value from a specified position of a negative number.
Execution:
  Arrange: No arrangement needed as we are directly dealing with a method that does not use other initialization or state mechanisms.
  Act: Invoke the getBit method from SingleBitOperations with a negative number and a valid bit position.
  Assert: Using JUnit assertion equalTo, check if the return value is 1 or 0 depending on the bitwise representation of the negative number.
Validation:
  Aim of this assertion is to verify if the method correctly handles negative numbers. This test is significant in ensuring the robustness of the bit operation handling for negative numbers.


Scenario 3: Get Bit from an out-of-bound position
Details:
  TestName: getBitFromOutOfBoundsPosition
  Description: This test checks the behavior of the getBit method when asked to retrieve a bit from an out-of-bound position.
Execution:
  Arrange: No arrangement needed as we are directly dealing with a method that does not use other initialization or state mechanisms.
  Act: Invoke the getBit method from SingleBitOperations with a positive number and an out-of-bound bit position.
  Assert: Using JUnit assertion equalTo, check if the return value is 0 as out-of-bound positions should not have any bit set.
Validation:
  Aim of this assertion is to verify the behavior of the method when asked for an out-of-bound bit. This test is significant to determine the robustness of the system when encountering erroneous inputs.


Scenario 4: Get Bit at position 0 of a number zero
Details:
  TestName: getBitAtPosition0FromZero
  Description: This test checks the getBit method to retrieve the bit value from position 0 of the number 0.
Execution:
  Arrange: No arrangement needed as we are directly dealing with a method that does not use other initialization or state mechanisms.
  Act: Invoke the getBit method from SingleBitOperations with 0 as the input number and bit position 0.
  Assert: Using JUnit assertion equalTo, check if the return value is 0 since the bit at every position of the number 0 is 0.
Validation:
  Aim of this assertion is to verify if the method correctly returns the bit at position 0 of the number 0. This test is significant in ensuring the correctness of the bit operation for the base case of zero.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.*;

public class SingleBitOperationsGetBitTest {

	@Test
	@Tag("valid")
	public void getBitAtPosition0FromPositiveNumber() {
		int num = 5; // Binary representation: 101
		int bit = 0;
		int expectedBitValue = 1;
		int result = SingleBitOperations.getBit(num, bit);
		assertEquals(expectedBitValue, result);
	}

	@Test
	@Tag("valid")
	public void getBitFromNegativeNumber() {
		int num = -5; // Binary representation is the two's complement of positive version
		int bit = 0;
		int expectedBitValue = 1;
		int result = SingleBitOperations.getBit(num, bit);
		assertEquals(expectedBitValue, result);
	}

	@Test
	@Tag("boundary")
	public void getBitFromOutOfBoundsPosition() {
		int num = 5; // Binary representation: 101
		int bit = 5; // Out-of-bounds for our number
		int expectedBitValue = 0; // Out-of-bounds positions should not have any bit set
		int result = SingleBitOperations.getBit(num, bit);
		assertEquals(expectedBitValue, result);
	}

	@Test
	@Tag("boundary")
	public void getBitAtPosition0FromZero() {
		int num = 0; // Binary representation: 0
		int bit = 0;
		int expectedBitValue = 0; // Zero has all bits 0
		int result = SingleBitOperations.getBit(num, bit);
		assertEquals(expectedBitValue, result);
	}

}