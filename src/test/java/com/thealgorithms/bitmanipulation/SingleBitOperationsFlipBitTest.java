
// ********RoostGPT********
/*
Test generated by RoostGPT for test Java-test-1 using AI Type  and AI Model

ROOST_METHOD_HASH=flipBit_cc971e4a99
ROOST_METHOD_SIG_HASH=flipBit_219935ae9f

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/Java-test-1/4fe02726-06d9-4581-a823-6990ffcbda14/source/Algorithms_Java/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void flipBitTest() {
    assertEquals(1, SingleBitOperations.flipBit(3, 1));
    assertEquals(11, SingleBitOperations.flipBit(3, 3));
}
""""
Scenario 1: Flipping a bit at zero position in a non-zero number

TestName: flipBitAtZeroPositionInNonZeroNum
Description: A test to validate when flipping the bit at zero position in a non-zero number.
Execution:
  Arrange: Nothing to arrange, as there is no state or dependency to prepare.
  Act: Invoke SingleBitOperations.flipBit with parameters 1 and 0.
  Assert: Use JUnit assertions to expect 0.
Validation:
  The assertion verifies that the bit at the '0' position in the number '1' has been successfully flipped. The bit at zero position in '1' is '1' and flipping it should give '0'.

Scenario 2: Flipping a bit beyond the size of the input number

TestName: flipBitBeyondLengthOfNum
Description: A test to validate when flipping a bit position which is beyond the size of the input number.
Execution:
  Arrange: Nothing to arrange, as there is no state or dependency to prepare.
  Act: Invoke SingleBitOperations.flipBit with parameters 3 and 4.
  Assert: Use JUnit assertions to expect 19.
Validation:
  The assertion verifies that the bit at the '4' position, which is beyond the size of '3', is flipped successfully. The original number 3 in binary is '11', and flipping '4'th bit should give '10011', which is 19 in decimal.

Scenario 3: Flipping bit at position in a large number

TestName: flipBitInLargeNum
Description: Test to validate flipping the bit at a certain position in a larger number
Execution:
  Arrange: Nothing to arrange, as there is no state or dependency to prepare.
  Act: Invoke SingleBitOperations.flipBit with parameters 1024 and 10.
  Assert: Use JUnit assertions to expect 0.
Validation:
  The assertion verifies that the bit at the '10' position in the number '1024' has been successfully flipped. The bit at 10th position in '1024' is '1' and flipping it should return '0'.

Scenario 4: Flipping bit at negative position

TestName: flipBitAtNegativePosition
Description: A test to validate the behavior when trying to flip a bit at negative position.
Execution:
  Arrange: Nothing to arrange, as there is no state or dependency to prepare.
  Act: Invoke SingleBitOperations.flipBit with parameters 1 and -1.
  Assert: Assert that an IllegalArgumentException is thrown.
Validation:
  The purpose of the test is to validate that the function behaves as expected when trying to flip a bit at a negative position. This is an edge case to verify the error handling capabilities of the function.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.*;

public class SingleBitOperationsFlipBitTest {

	@Test
	@Tag("valid")
	public void flipBitAtZeroPositionInZeroNum() {
		// ARRANGE
		int expectedValue = 0;
		// ACT
		int actualValue = SingleBitOperations.flipBit(1, 0);
		// ASSERT
		Assertions.assertEquals(expectedValue, actualValue, "Flip bit at position zero in one should yield zero");
	}

	@Test
	@Tag("valid")
	public void flipBitBeyondLengthOfNum() {
		// ARRANGE
		int expectedValue = 19;
		// ACT
		int actualValue = SingleBitOperations.flipBit(3, 4);
		// ASSERT
		Assertions.assertEquals(expectedValue, actualValue,
				"Flip bit at position beyond size of number 3 should yield 19");
	}

	@Test
	@Tag("valid")
	public void flipBitInLargeNum() {
		// ARRANGE
		int expectedValue = 0;
		// ACT
		int actualValue = SingleBitOperations.flipBit(1024, 10);
		// ASSERT
		Assertions.assertEquals(expectedValue, actualValue, "Flip bit at position 10 in 1024 should yield zero");
	}

	@Test
	@Tag("invalid")
	public void flipBitAtNegativePosition() {
		// ARRANGE
		IllegalArgumentException thrownException = Assertions.assertThrows(IllegalArgumentException.class,
				// ACT
				() -> SingleBitOperations.flipBit(1, -1));
		// ASSERT
		Assertions.assertTrue(thrownException.getMessage().contains("Negative bit position"));
	}

}