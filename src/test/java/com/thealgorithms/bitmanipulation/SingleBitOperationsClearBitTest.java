
// ********RoostGPT********
/*
Test generated by RoostGPT for test Java-test-1 using AI Type  and AI Model

ROOST_METHOD_HASH=clearBit_2bb8df5689
ROOST_METHOD_SIG_HASH=clearBit_41db29e3ee

Here are your existing test cases which we found out and are not considered for test generation:

File Path: /var/tmp/Roost/RoostGPT/Java-test-1/4fe02726-06d9-4581-a823-6990ffcbda14/source/Algorithms_Java/src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java
Tests:
    "@Test
@Test
public void clearBitTest() {
    assertEquals(5, SingleBitOperations.clearBit(7, 1));
    assertEquals(5, SingleBitOperations.clearBit(5, 1));
}
""""
Scenario 1: Test the clearBit method with positive numbers
Details:
  TestName: testClearBitWithPositiveNumbers
  Description: The test aims to verify the 'clearBit' method when both input parameters 'num' and 'bit' are positive. The clearBit method should clear the specified bit of 'num' successfully.
  Execution:
    Arrange: No arrangement is needed as we directly provide the input with positive integers.
    Act: Invoke the clearBit method with positive numbers for 'num' and 'bit'.
    Assert: Use Junit assertions to verify the result of clearing a specific bit from 'num'.
  Validation:
    The test confirms whether the 'clearBit' method correctly handles positive numbers. The expected result is the integer that results after the specified bit is cleared from 'num'.

Scenario 2: Test the clearBit method with negative 'num' value
Details:
  TestName: testClearBitWithNegativeNum
  Description: This test validates if the 'clearBit' method works correctly when the 'num' parameter is negative. The method should clear the specified bit from 'num' regardless.
  Execution:
    Arrange: No arrangement is necessary as we directly provide the 'num' parameter with a negative integer value.
    Act: Call the clearBit method with a negative number for 'num' and a positive integer for 'bit'.
    Assert: Use JUnit assertions to compare the actual result of the clearBit method and expected output.
  Validation:
    The test aims to confirm whether the 'clearBit' method correctly handles negative 'num' parameter. The method should return the number that results after the specified bit of 'num' is cleared.

Scenario 3: Test the clearBit method with a negative 'bit' value
Details:
  TestName: testClearBitWithNegativeBit
  Description: This test aims to verify the 'clearBit' method when the 'bit' parameter is negative. Since standard binary operation rules do not define bit manipulation for negative 'bit' parameters, a test for appropriate exception or error handling should be carried out.
  Execution:
    Arrange: No arrangement is necessary as we directly provide a negative integer to 'bit'.
    Act: Invoke the clearBit method with 'bit' as a negative integer.
    Assert: Use JUnit assertions to check for any exception or error handling.
  Validation:
    This test verifies whether the method correctly handles 'bit' parameter as a negative integer. Ideally, it should throw an exception or error since unsigned bitwise shift operations with negative numbers are undefined in binary operations.

Scenario 4: Test the clearBit method with 'bit' value greater than the bit size of 'num'.
Details:
  TestName: testClearBitWithBitValueMoreThanBitSizeOfNum
  Description: The test is meant to validate if the 'clearBit' method can handle a situation where the value of 'bit' is greater than the bit size of 'num'. The method should either handle the request without issues or throw an error/exception.
  Execution:
    Arrange: No special setup is required as we provide direct inputs to the method.
    Act: Invoke the clearBit method with 'bit' value greater than the bit size of 'num'.
    Assert: Use JUnit assertions to either verify the result or confirm the error/exception thrown.
  Validation:
    This test confirms if the 'clearBit' method correctly handles a scenario where 'bit' value is greater than the number of bits in 'num'. Expected behavior depends on how method is designed to handle such cases.
"""
*/

// ********RoostGPT********

package com.thealgorithms.bitmanipulation;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;

public class SingleBitOperationsClearBitTest {

	@Test
	@Tag("valid")
	public void testClearBitWithPositiveNumbers() {
		// Act
		int result = SingleBitOperations.clearBit(15, 2);
		// Assert
		assertEquals(11, result, "Clear bit operation does not produce the expected result.");
	}

	@Test
	@Tag("valid")
	public void testClearBitWithNegativeNum() {
		// Act
		int result = SingleBitOperations.clearBit(-8, 3);
		// Assert
		assertEquals(-8, result, "Clear bit operation does not produce the expected result.");
	}

	@Test
	@Tag("invalid")
	public void testClearBitWithNegativeBit() {
		// Assert
		assertThrows(ArithmeticException.class, () -> {
			// Act
			SingleBitOperations.clearBit(10, -3);
		}, "Expected to throw an exception but did not.");
	}

	@Test
	@Tag("boundary")
	public void testClearBitWithBitValueMoreThanBitSizeOfNum() {
		// Act
		int result = SingleBitOperations.clearBit(15, 5);
		// Assert
		assertEquals(15, result, "Clear bit operation does not produce the expected result.");
	}

}