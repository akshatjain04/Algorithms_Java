// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview
ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f
```
Scenario 1: No overlapping activities
Details:
  TestName: selectNonOverlappingActivities
  Description: This test checks if the method correctly selects activities that do not overlap with each other.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with non-overlapping activity times.
  Act: Call activitySelection with the prepared arrays.
  Assert: Verify that the returned list contains all activities as they do not overlap.
Validation:
  The assertion checks that all activities are selected since each subsequent activity starts after the previous one ends. This validates the method's ability to handle non-overlapping activities.
Scenario 2: All activities overlap
Details:
  TestName: selectSingleActivityFromAllOverlapping
  Description: This test verifies that when all activities overlap, only one is selected.
Execution:
  Arrange: Initialize startTimes and endTimes arrays where all activities overlap.
  Act: Call activitySelection with the prepared arrays.
  Assert: Check that the returned list contains only one activity.
Validation:
  The assertion aims to verify that the algorithm selects the first activity and excludes the rest due to overlap, demonstrating the method's correct behavior in handling overlapping activities.
Scenario 3: Some activities overlap
Details:
  TestName: selectMaximumNonOverlappingActivities
  Description: This test ensures that the method selects the maximum number of non-overlapping activities from a mix of overlapping and non-overlapping activities.
Execution:
  Arrange: Initialize startTimes and endTimes with a combination of overlapping and non-overlapping activity times.
  Act: Call activitySelection with the prepared arrays.
  Assert: Ensure that the returned list contains the maximum number of non-overlapping activities.
Validation:
  The assertion confirms that the method correctly identifies and selects the maximum number of activities that can take place without any overlap, affirming the greedy algorithm's correctness.
Scenario 4: Empty activity lists
Details:
  TestName: selectNoActivitiesWhenEmptyLists
  Description: This test checks the method's response to empty activity lists.
Execution:
  Arrange: Initialize startTimes and endTimes arrays as empty.
  Act: Call activitySelection with the empty arrays.
  Assert: Confirm that the returned list is empty.
Validation:
  The assertion validates that the method handles empty input correctly by returning an empty list, ensuring robustness in edge cases.
Scenario 5: Single activity
Details:
  TestName: selectSingleActivityWhenOneAvailable
  Description: This test validates that the method selects a single activity when there is only one available.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with one activity's start and end times.
  Act: Call activitySelection with the prepared arrays.
  Assert: Verify that the returned list contains the single available activity.
Validation:
  The assertion checks that the method functions correctly when there's only one activity, confirming its ability to handle the simplest case.
Scenario 6: Activities with the same end time
Details:
  TestName: selectOneActivityWithSameEndTime
  Description: This test examines the method's ability to handle activities that have the same end time.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with multiple activities ending at the same time.
  Act: Call activitySelection with the prepared arrays.
  Assert: Ensure that the returned list contains only one of the activities with the same end time.
Validation:
  The assertion verifies that the method selects only one activity when multiple activities share the same end time, showing the algorithm's correct prioritization behavior.
Scenario 7: Incorrectly ordered input times
Details:
  TestName: selectActivitiesWithUnorderedInputTimes
  Description: This test ensures that the method can handle input arrays where the activities are not sorted by their end times.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with activities not sorted by end times.
  Act: Call activitySelection with the unsorted arrays.
  Assert: Confirm that the returned list contains activities selected in a proper order.
Validation:
  The assertion checks that the method sorts the activities by end time internally and selects them correctly, testing the method's robustness against unsorted input.
```
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.datastructures.bags")
@Tag("com.thealgorithms.datastructures.bags.add")
@Tag("com.thealgorithms.datastructures.bags.add")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
public class ActivitySelectionActivitySelectionTest {

	// No changes needed for this test case as it is passing
	@Test
	public void selectNonOverlappingActivities() {
		int[] startTimes = { 1, 3, 5, 7 };
		int[] endTimes = { 2, 4, 6, 8 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 2, 3));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectSingleActivityFromAllOverlapping() {
		int[] startTimes = { 1, 1, 1 };
		int[] endTimes = { 2, 2, 2 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectMaximumNonOverlappingActivities() {
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 6, 7, 9, 9 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 3, 4));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectNoActivitiesWhenEmptyLists() {
		int[] startTimes = {};
		int[] endTimes = {};
		ArrayList<Integer> expected = new ArrayList<>();
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectSingleActivityWhenOneAvailable() {
		int[] startTimes = { 1 };
		int[] endTimes = { 2 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectOneActivityWithSameEndTime() {
		int[] startTimes = { 1, 2, 3 };
		int[] endTimes = { 4, 4, 4 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

	// No changes needed for this test case as it is passing
	@Test
	public void selectActivitiesWithUnorderedInputTimes() {
		int[] startTimes = { 5, 1, 3, 0, 8, 5 };
		int[] endTimes = { 9, 2, 4, 6, 9, 7 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
		ArrayList<Integer> actual = ActivitySelection.activitySelection(startTimes, endTimes);
		assertEquals(expected, actual);
	}

}